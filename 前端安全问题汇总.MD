### 前端安全问题汇总
---
#### 目录
- <a href="#xss">xss攻击</a>
- <a href="#iframe">iframe 危害</a>
- <a href="#click">点劫持</a>
- <a href="#error">错误的内容推断</a>
- <a href="#her">第三方库的安全性</a>
- <a href="#store">浏览器缓存安全</a>
- <a href="#http">http跳转https时的危险</a>
- <a href="#cdn">CDN（内容分发服务的安全防范）</a>
---
#### <a name="xss">xss攻击</a>：

###### 解释
> XSS是跨站脚本攻击（Cross-Site Scripting）的简称，XSS这类安全问题发生的本质原因在于，浏览器错误的将攻击者提供的用户输入数据当做JavaScript脚本给执行了。

###### xss危害
     1. 通过document.cookie盗取cookie
     2. 使用js或css破坏页面正常的结构与样式
     3. 流量劫持（通过访问某段具有window.location.href定位到其他页面）
     4. Dos攻击：利用合理的客户端请求来占用过多的服务器资源，从而使合法用户无法得到服务器响应。
     5. 利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。
     6. 利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。
###### xss方式

- 反射型

    反射型XSS，也叫非持久型XSS，是指发生请求时，XSS代码出现在请求URL中，作为参数提交到服务器，服务器解析并响应。响应结果中包含XSS代码，最后浏览器解析并执行。
- 储存型

    存储型XSS，也叫持久型XSS，主要是将XSS代码发送到服务器（不管是数据库、内存还是文件系统等。），然后在下次请求页面的时候就不用带上XSS代码了，最典型就是留言板xss攻击
- DOM XSS

    主要是使用 eval 的原因导致写入的内容直接执行

###### xss防御
1. 对cookie进行 httpOnly 设置，让JS无法获取cookie就可以，这个需要后端去做
2. 对用户输入的数据进行关键字过滤
3. 对用户输入的数据进行编码，然后体现的时候进行解译
4. 避免使用 js的 eval 方法

---
#### <a name="iframe">iframe 第三方页面</a>

###### 解释

> 页面嵌入了有损害性的 iframe

###### 危害
- 因为iframe中的内容是由第三方来提供的，默认情况下他们不受我们的控制，他们可以在iframe中运行JavaScirpt脚本、Flash插件、弹出对话框等等，这可能会破坏前端用户体验。
- 如果iframe中的域名因为过期而被恶意攻击者抢注，或者第三方被黑客攻破，iframe中的内容被替换掉了，从而利用用户浏览器中的安全漏洞下载安装木马、恶意勒索软件等等，这问题可就大了。

###### 防御



- iframe有了一个叫做sandbox的安全属性，通过它可以对iframe的行为进行各种限制，充分实现“最小权限“原则。使用sandbox的最简单的方式就是只在iframe元素中添加上这个关键词就好，就像下面这样：

    ```html
    <iframe sandbox src="..."> ... </iframe>
    ```
    > 另外，sandbox也提供了丰富的配置参数，我们可以进行较为细粒度的控制。一些典型的参数如下：
    > - allow-forms：允许iframe中提交form表单
    > - allow-popups：允许iframe中弹出新的窗口或者标签页（例如，window.open()，showModalDialog()，target=”_blank”等等）
    > - allow-scripts：允许iframe中执行JavaScript
    > - allow-same-origin：允许iframe中的网页开启同源策略

---

#### <a name="click">点劫持</a>

###### 解释

> 自己的页面也可能正在被不法分子放到他们精心构造的iframe或者frame当中，进行点击劫持攻击。
> - 攻击者精心构造一个诱导用户点击的内容，比如Web页面小游戏
> - 将我们的页面放入到iframe当中
> - 利用z-index等CSS样式将这个iframe叠加到小游戏的垂直方向的正上方
> - 把iframe设置为100%透明度
> - 受害者访问到这个页面后，肉眼看到的是一个小游戏，如果受到诱导进行了点击的话，实际上点击到的却是iframe中的我们的页面

###### 危害

 点击劫持的危害在于，攻击利用了受害者的用户身份，在其不知情的情况下进行一些操作。如果只是迫使用户关注某个微博账号的话，看上去仿佛还可以承受，但是如果是删除某个重要文件记录，或者窃取敏感信息，那么造成的危害可就难以承受了。

###### 防御

服务器配置使用X-Frame-Options：DENY这个HTTP Header来明确的告知浏览器，不要把当前HTTP响应中的内容在HTML Frame中显示出来。

---

#### <a name="error">错误的内容推断</a>

###### 解释
> 想象一下这样一个攻击场景：某网站允许用户在评论里上传图片，攻击者在上传图片的时候，看似提交的是个图片文件，实则是个含有JavaScript的脚本文件。该文件逃过了文件类型校验（这涉及到了恶意文件上传这个常见安全问题，但是由于和前端相关度不高因此暂不详细介绍），在服务器里存储了下来。接下来，受害者在访问这段评论的时候，浏览器会去请求这个伪装成图片的JavaScript脚本，而此时如果浏览器错误的推断了这个响应的内容类型（MIME types），那么就会把这个图片文件当做JavaScript脚本执行，于是攻击也就成功了。

> 问题的关键就在于，后端服务器在返回的响应中设置的Content-Type Header仅仅只是给浏览器提供当前响应内容类型的建议，而浏览器有可能会自作主张的根据响应中的实际内容去推断内容的类型。

###### 防御

- 后端服务器返回的Content-Type建议浏览器按照图片进行内容渲染，浏览器发现有X-Content-Type-OptionsHTTP Header的存在，并且其参数值是nosniff，因此不会再去推断内容类型，而是强制按照图片进行渲染，那么因为实际上这是一段JS脚本而非真实的图片，因此这段脚本就不会被浏览器执行。

---

#### <a name="her">不安全的第三方依赖包</a>

###### 解释
> 我们在引入库的同时，库的漏洞也会成为我们的漏洞,造成各种各样的xss攻击或者别的攻击

###### 防御
- 手动检查这些第三方代码有没有安全问题是个苦差事，主要是因为应用依赖的这些组件数量众多，手工检查太耗时，好在有自动化的工具可以使用，比如NSP(Node Security Platform)，Snyk等等。

---

#### <a name="http">HTTPS 被拦截</a>

###### 解释

> 浏览器发出去的第一次请求就被攻击者拦截了下来并做了修改，根本不给浏览器和服务器进行HTTPS通信的机会。大致过程如下，用户在浏览器里输入URL的时候往往不是从https://开始的，而是直接从域名开始输入，随后浏览器向服务器发起HTTP通信，然而由于攻击者的存在，它把服务器端返回的跳转到HTTPS页面的响应拦截了，并且代替客户端和服务器端进行后续的通信。由于这一切都是暗中进行的，所以使用前端应用的用户对此毫无察觉。

###### 防御

- 解决这个安全问题的办法是使用HSTS（HTTP Strict Transport Security），它通过下面这个HTTP Header以及一个预加载的清单，来告知浏览器在和网站进行通信的时候强制性的使用HTTPS，而不是通过明文的HTTP进行通信：
    ```
    Strict-Transport-Security: max-age=<seconds>; includeSubDomains; preload
    ```
- 这里的“强制性”表现为浏览器无论在何种情况下都直接向服务器端发起HTTPS请求，而不再像以往那样从HTTP跳转到HTTPS。另外，当遇到证书或者链接不安全的时候，则首先警告用户，并且不再让用户选择是否继续进行不安全的通信。

---
#### <a name="store">本地存储数据泄露</a>
###### 解释
> 假设你的前端应用想要支持离线模式，使得用户在离线情况下依然可以使用你的应用，而这就意味着你需要在本地存储用户相关的一些数据，比如说像电子邮箱地址、手机号、家庭住址等PII（Personal Identifiable Information）信息，或许还有历史账单、消费记录等数据。
> 尽管有浏览器的同源策略限制，但是如果前端应用有XSS漏洞，那么本地存储的所有数据就都可能被攻击者的JS脚本读取到。如果用户在公用电脑上使用了这个前端应用，那么当用户离开后，这些数据是否也被彻底清除了呢？
###### 防御
- 前端对数据加密后再存储看上去是个防御办法，但其实仅仅只是提高了一点攻击门槛而已，因为加密所用到的密钥同样存储在前端，有耐心的攻击者依然可以攻破加密这道关卡。
- 推荐的做法是尽可能不在前端存这些数据。
---
#### <a name="cdn">缺乏静态资源完整性校验</a>
###### 解释
> 出于性能考虑，前端应用通常会把一些静态资源存放到CDN（Content Delivery Networks）上面，例如Javascript脚本和Stylesheet文件。这么做可以显著提高前端应用的访问速度，但与此同时却也隐含了一个新的安全风险。（*CDN为内容分发服务，可以就近发送资源，让网页加载更快*）
> 如果攻击者劫持了CDN，或者对CDN中的资源进行了污染，那么我们的前端应用拿到的就是有问题的JS脚本或者Stylesheet文件，使得攻击者可以肆意篡改我们的前端页面，对用户实施攻击。这种攻击方式造成的效果和XSS跨站脚本攻击有些相似，不过不同点在于攻击者是从CDN开始实施的攻击，而传统的XSS攻击则是从有用户输入的地方开始下手的。

###### 防御
- 防御这种攻击的办法是使用浏览器提供的SRI（Subresource Integrity）功能。顾名思义，这里的Subresource指的就是HTML页面中通过< script >和< link >元素所指定的资源文件。
每个资源文件都可以有一个SRI值，就像下面这样。它由两部分组成，减号（-）左侧是生成SRI值用到的哈希算法名，右侧是经过Base64编码后的该资源文件的Hash值。

    ```html
    <script src=“https://example.js” integrity=“sha384-eivAQsRgJIi2KsTdSnfoEGIRTo25NCAqjNJNZalV63WKX3Y51adIzLT4So1pk5tX”></script>
    ```
- 浏览器在处理这个script元素的时候，就会检查对应的JS脚本文件的完整性，看其是否和script元素中integrity属性指定的SRI值一致，如果不匹配，浏览器则会中止对这个JS脚本的处理。