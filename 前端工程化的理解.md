## 前端工程化的理解
---
### 什么是前端工程化?

> 前端工程化是使用软件工程的技术和方法来进行前端的开发流程、技术、工具、经验等规范化、标准化。

### 前端工程化的目的:

> 为了提高效率和降低成本，即提高开发过程中的开发效率，减少不必要的重复工作时间

### 前端工程化的重点:

> 利用分治思想化整为0，便于管理迭代，运维

### 前端工程化的主要包含什么:

- 模块化
- 组件化
- 规范化
- 自动化

##### 模块化

> 简单来说，模块化就是将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载。

- JS 模块化
    - commonJS 
        > 是同步加载JS的，会造成堵塞，不适合浏览器，更多是服务器在用
    - AMD规范
        > require.js 遵从的规范，依赖前置 ,可以异步加载js
    - CMD规范
        > sea.js 遵从的规范，什么时候使用 什么时候加载依赖，可以异步加载js
    - ES6的 modul
        > 更为简洁，而且可以静态加载，动态引用（js引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用）

- css 模块化 
    > 虽然SASS、LESS、Stylus等预处理器实现了CSS的文件拆分，但没有解决CSS模块化的一个重要问题：选择器的全局污染问题。
    
    -  VUE的scoped style 也算是一种解决css模块化的方式
    
    - CSS Modules仍然使用CSS，只是让JS来管理依赖。它能够最大化地结合CSS生态和JS模块化能力，目前来看是最好的解决方案。

    - 为了避免全局选择器的冲突，需要制定CSS命名风格：
        - BEM风格
        - Bootstrap风格


- 资源的模块化（img,或者字体文件等等）

    > 资源包括 img 以及库的使用，以及字体文件这些，这些都可以通过webpack模块机制加载，所以重点在于webpack

    - 优点
        - 依赖关系单一化：所有CSS和图片等资源的依赖关系统一走JS路线，无需额外处理CSS预处理器的依赖关系，也不需处理代码迁移时的图片合并、字体图片等路径问题； 
        - 资源处理集成化：现在可以用loader对各种资源做各种事情，比如复杂的vue-loader等等；
        -项目结构清晰化：使用Webpack后，你的项目结构总可以表示成这样的函数： dest = webpack(src, config)。

##### 组件化

> 从UI拆分下来的每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元，我们称之为组件。

> 组件化≠模块化。模块化只是在文件层面上，对代码或资源的拆分；而组件化是在设计层面上，对UI（用户界面）的拆分。

 常用的组件化框架主要的有 `Vue、React、Angular`，还有小程序。

 自己构建组件化项目，需要处理引入方式使用webpack，所以选用框架是最好的方法。

 - 链接：[不用框架的情况下如何组件化](https://segmentfault.com/a/1190000011774228)

##### 规范化

> 规范化其实是工程化中很重要的一个部分，项目初期规范制定的好坏会直接影响到后期的开发质量。
- 目录结构的制定

    优点：
    1. 有助于提高项目的逻辑结构合理性
    2. 对应扩展和合作
    3. 方便资源的统一定位管理

- 编码规范包括
    
    - HTML规范
        >基于 W3C、苹果开发者 等官方文档，并结合团队业务和开发过程中总结的规范约定，让页面HTML代码更具语义性。
    - CSS规范
        >统一规范团队 CSS 代码书写风格和使用 CSS 预编译语言语法风格，提供常用媒体查询语句和浏览器私有属性引用，并从业务层面统一规范常用模块的引用。
    - JS规范
        >统一规范团队 CSS 代码书写风格和使用 CSS 预编译语言语法风格，提供常用媒体查询语句和浏览器私有属性引用，并从业务层面统一规范常用模块的引用。
    - 图片规范
        >了解各种图片格式特性，根据特性制定图片规范，包括但不限于图片的质量约定、图片引入方式、图片合并处理等，旨在从图片层面优化页面性能。
    - 命名规范
        >从 目录、图片、HTML/CSS文件、ClassName 的命名等层面约定规范团队的命名习惯，增强团队代码的可读性。

- 前后端接口规范

    - 职责分离
        1. 前后端仅仅通过异步接口(AJAX/JSONP)来编程；
        2. 前后端都各自有自己的开发流程，构建工具，测试集合；
        3. 关注点分离，前后端变得相对独立并松耦合。

        前端|后端
        :-:|:-:
        接收数据，返回数据|提供数据
        处理渲染逻辑|处理业务逻辑

    - 规范原则
        1. 接口返回数据即显示，前端仅做渲染逻辑处理；
        2. 渲染逻辑禁止跨多个接口调用；
        3. 前端关注交互、渲染逻辑，尽量避免业务逻辑处理的出现；
        4. 请求响应传输数据格式：JSON，JSON数据尽量简单轻量，避免多级JSON的出现；
    
    - 响应格式
        1. 响应基本格式及处理状态值的规范
            - 基本响应格式
            - 列表响应格式
        2. 特殊内容
            - 下拉框、复选框、单选框统一由后端逻辑判定选中返回给前端展示；
            - 关于Boolean类型，JSON数据传输中一律使用1/0来标示，1为是/True，0为否/False
            - 关于日期类型，JSON数据传输中一律使用字符串，具体日期格式因业务而定；
- git分支管理
    > 根据技术团队现状，分为不同的开发分支，灵活的进行协作和测试发布工作。
- commit描述规范
    > 对每条提交的描述做清楚的阐述，对以后的 review code 有极大帮助

##### 自动化

> 前端工程化的很多脏活累活都应该交给自动化工具来完成。需要秉持的一个理念是:任何简单机械的重复劳动都应该让机器去完成。

- 版本管理
    > 版本管理就是为了更好地团体协作，以及方便追溯历史文件，以及相关的文件修改内容。现在市场主要分两种，git与svn
    - git

    - svn

- 图标合并
    - iconfont
        > 字形文件，减少请求资源，对设计要求较高。
    - 利用打包器进行图标合成，webpack等
       > 利用打包软件，把图标资源打包成sprite图（雪碧图）；
- 持续集成
    > 集成就是把所有分支的代码进行合并，查看项目是否正常。持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。

    - jenkins

    利用自动的持续集成工具，来不断 build 代码，如果代码第一时间出错，立马通知代码管理人员进行修改，保持线上代码的可用性


- 自动化构建
    > 自动化构建就是将源代码利用工具自动转换成用户可以使用的目标的过程。'目标'在这里指的是js,css,html的集合。'用户'可以是你、测试或者真正的用户。

    **自动构建的问题**

    - 文件压缩问题，文件大小—都是源码发布,所有文件都没有经过压缩合并处理，客户端访问需要逐个建立http会话下载资源,会很慢。
    - 文件hash指纹问题，一致性—没有版本管理,假设果客户端已经缓存a.jpg文件,而事实上你新的发布已经修改了a.jpg,客户端需要手动刷新缓存才能看到新的内容。
    - 热加载问题，你每次修改新的内容都需要重新推送到webSrv并且手动刷新浏览器
    
    **常用的构建工具**
    
    - webpack
    - gulp
