# 浏览器中的页面循环系统

 

## 消息队列和事件循环：页面是怎么“活”起来的？

### 使用单线程处理安排好的任务

- 缺点
  - 无法接受新的任务
- 解决方案
  - 利用事件循环来收集新的任务
  - 条件
    - 引入循环机制，for循环语句
    - 引入事件

具体如下

![img](https://static001.geekbang.org/resource/image/9e/e3/9e0f595324fbd5b7cd1c1ae1140f7de3.png)

### 处理其他线程发送过来的任务（多线程处理）

上面只适用单线程，如果是多线程 如下

![img](https://static001.geekbang.org/resource/image/2e/05/2eb6a8ecb7cb528da4663573d74eb305.png)

处理这种模式 就需要 用到**消息队列**

- 解决方案
  - 利用消息队列，是一种数据结构，可以存放要执行的任务，符合队列“先进先出”的特点，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。
- 改造步骤
  - 添加一个消息队列
  - IO 线程中产生的新任务添加进消息队列尾部
  - 渲染主线程会循环地从消息队列头部中读取任务，执行任务

如下

![img](https://static001.geekbang.org/resource/image/2a/ab/2ac6bc0361cb4690c5cc83d8abad22ab.png)

### 处理多进程发送过的任务

消息队列可以处理多线程通信，但是浏览器还需要多进程任务，其实和多线程一样，**渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息**

![img](https://static001.geekbang.org/resource/image/e2/c6/e2582e980632fd2df5043f81a11461c6.png)

### 消息队列中的任务类型

- 内部消息类型
  - 输入事件（鼠标滚动点击移动）
  - 微任务
  - 文件读写
  - websocket
  - JS的定时器
  - ...
- 页面相关的事件
  - JS执行
  - 解析DOM
  - 样式计算
  - 布局计算
  - css动画

以上这些事件都是在主线程中执行的，所以在编写 Web 应用时，你还需要衡量这些事件所占用的时长，并想办法解决单个任务占用主线程过久的问题。

### 安全退出线程

确定要退出当前页面时，页面主线程会设置一个退出标志的变量，在每次执行完一个任务时

### 页面使用单线程的缺点

页面线程所有执行的任务都来自于消息队列。消息队列是“先进先出”的属性，也就是说放入队列中的任务，需要等待前面的任务被执行完，才会被执行。

- 如何处理高优先级的任务
  - 消息队列中每个任务都是宏任务，在执行宏任务时，有例如DOM渲染这样的**微任务**执行那么就添加到当前宏任务的微任务队列，当宏任务的主任务列表执行完后，就会开始执行**微任务**列表
- 如何处理一个任务时长过长的问题
  - 所有任务是单线程执行，每次只能执行一个任务，任务时长过长就会导致后面的任务长时间等待，JavaScript 可以通过回调功能来规避这种问题，也就是让要执行的 JavaScript 任务滞后执行。

## WebAPI:setTimeout是如何实现的？

- 新建了一个 **延迟任务**消息队列，所有定时器都会在这个队列中
- 每当一个消息队列中的宏任务执行完成，就会执行 **延迟任务**消息队列中的任务（所以有时延时函数执行等待时长会比定时长）
- clearTimeout 实现就是传入 setTimeout 返回的 number，通过这个查找到相关的事件 id 然后在 延时队列中删掉即可

### 使用setTimeout 的注意事项

- 当前任务执行事件过久，会影响定时器任务的执行

  - 如下

  - ```js
    
    function bar() {
        console.log('bar')
    }
    function foo() {
        setTimeout(bar, 0);
        for (let i = 0; i < 5000; i++) {
            let i = 5+8+8+8
            console.log(i)
        }
    }
    foo()
    // 虽然延时 0 秒，但是需要先把 for 循环走完 才能走 延时函数，所以真实延时就是for循环走完后的时间
    ```

- 如果 setTimeout 存在嵌套调用，那么浏览器系统会设置最短时间间隔为 4 毫秒

- 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒

  - 如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1000 毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。

- 延时执行时间有最大值

  - Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，那么相当于延时值被设置为 0 了，这导致定时器会被立即执行。

- 使用 setTimeout 设置的回调函数中的 this 不符合直觉

  - 如果被 setTimeout 推迟执行的回调函数是某个对象的方法，那么该方法中的 this 关键字将指向全局环境，而不是定义时所在的那个对象，如果是严格模式，会被设置为 undefined。

## WebAPI:XMLHttpRequest是怎么实现的？

先介绍下**同步回调**和**异步回调**这两个概念

### 回调函数 VS 系统调用栈

> 将一个函数作为参数传递给另外一个函数，那作为参数的这个函数就是回调函数。

- 同步回调

  ```js
  
  let callback = function(){
      console.log('i am do homework')
  }
  function doWork(cb) {
      console.log('start do work')
      cb()
      console.log('end do work')
  }
  doWork(callback)
  ```

  回调函数 callback 是在主函数 doWork 返回之前执行的，我们把这个回调过程称为同步回调

- 异步回调

  ```js
  
  let callback = function(){
      console.log('i am do homework')
  }
  function doWork(cb) {
      console.log('start do work')
      setTimeout(cb,1000)   
      console.log('end do work')
  }
  doWork(callback)
  ```

  在这个例子中，我们使用了 setTimeout 函数让 callback 在 doWork 函数执行结束后，又延时了 1 秒再执行，这次 callback 并没有在主函数 doWork 内部被调用，我们把这种回调函数在主函数外部执行的过程称为**异步回调**

 当循环系统在执行一个任务的时候，都要为这个任务维护一个系统调用栈。这个系统调用栈类似于 JavaScript 的调用栈，只不过系统调用栈是 Chromium 的开发语言 C++ 来维护的

每个任务在执行过程中都有自己的调用栈，那么同步回调就是在当前主函数的上下文中执行回调函数，这个没有太多可讲的。

异步回调是指回调函数在主函数之外执行，一般有两种方式：

- 第一种是把异步函数做成一个任务，添加到信息队列尾部（包含正常队列和延时队列）
- 第二种是把异步函数添加到微任务队列中，这样就可以在当前任务的末尾处执行微任务了。

### XMLHttpRequest 运作机制

![img](https://static001.geekbang.org/resource/image/29/c6/2914a052f4f249a52077692a22ee5cc6.png)

- 创建 XMLHttpRequest 对象。

- 为 xhr 对象注册回调函数

  - 主要有下面几种
    - ontimeout，用来监控超时请求，如果后台请求超时了，该函数会被调用；
    - onerror，用来监控出错信息，如果后台请求出错了，该函数会被调用；
    - onreadystatechange，用来监控后台请求过程中的状态，比如可以监控到 HTTP 头加载完成的消息、HTTP 响应体消息以及数据加载完成的消息等。

- 配置基础的请求信息

- 发起请求

  ​	渲染进程会将请求发送给网络进程，然后网络进程负责资源的下载，等网络进程接收到数据之后，就会利用 IPC （进程间通信）来通知渲染进程；渲染进程接收到消息之后，会将 xhr 的回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，就会根据相关的状态来调用对应的回调函数

### XMLHttpRequest 使用过程中的“坑”

- 跨域问题

- HTTPS 混合内容的问题

  HTTPS 混合内容是 HTTPS 页面中包含了不符合 HTTPS 安全要求的内容，比如包含了 HTTP 资源，通过 HTTP 加载的图像、视频、样式表、脚本等，都属于混合内容。

  

## 宏任务和微任务：不是所有任务都是一个待遇

### 宏任务

- 渲染事件（如解析 DOM、计算布局、绘制）；
- 用户交互事件（如鼠标点击、滚动页面、放大缩小等）；
- JavaScript 脚本执行事件；
- 网络请求完成、文件读写完成事件。

> 为了协调这些任务有条不紊地在主线程上执行，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个 for 循环，不断地从这些任务队列中取出任务并执行任务。我们把这些消息队列中的任务称为**宏任务**。

- 先从多个消息队列中选出一个最老的任务这个任务称为 oldestTask；
- 然后循环系统记录任务开始执行的时间，并把这个 oldestTask 设置为当前正在执行的任务；
- 当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个 oldestTask；
- 最后统计执行完成的时长等信息。

#### 缺点

- 宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的

### 微任务

> 微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前，当这个宏任务的主函数执行结束后开始执行。

所以异步有两种方式：

1. 第一种是把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数。
2. 第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的。

#### 流程

- JS执行脚本，V8创建一个全局执行上下文，在创建上下文同时也会在内部创建一个微任务队列。
- 执行主函数
- 然后执行微任务列表
- 微任务列表如果有宏任务，那么给任务队列增加任务
- 如果有微任务，给当前执行的微任务队列增加微任务
- WHATWG （超文本应用技术工作组）把执行微任务的时间点称为检查点

#### 如何产生微任务

- 使用 MutationObserver 监控某个 DOM 节点，用JS修改这个节点
- 使用Promise，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务。

#### 一点题外话，DOM监听的演变

- JS改变DOM需要通知浏览器做出渲染改变，之前是 Mutation Event 回调方式，只要DOM改变立马做出改变，DOM频繁改变导致 性能卡顿
- 后来换为了 MutationObserver，为异步调用，可以不用在每次 DOM 变化都触发异步调用，而是等多次 DOM 变化后，一次触发异步调用，使用数据结构来记录这期间所有的DOM变化
- 渲染引擎将变化记录封装成微任务，并将微任务添加进当前的微任务队列中。

## 使用Promise，告别回调函数

### 出现原因

- 异步编程问题：代码逻辑不连续
  - 解决方案，利用回调函数
- 封装异步代码，让处理流程变得线性
  - 会导致无限的回调地狱
  - 会导致任务的不确定性，执行每个任务都有两种可能的结果（成功或者失败），所以体现在代码中就需要对每个任务的执行结果做两次判断，这种对每个任务都要进行一次额外的错误处理的方式，明显增加了代码的混乱程度。

### 解决思路

- 消灭嵌套
- 合并多个任务的错误处理

Promise 实现了这两种

### Promise与微任务

## async/await：使用同步的方式去写异步代码

### 生成器VS协程

> 生成器函数是一个带星号函数，而且是可以暂停执行和恢复执行的

```js

function* genDemo() {
    console.log("开始执行第一段")
    yield 'generator 2'

    console.log("开始执行第二段")
    yield 'generator 2'

    console.log("开始执行第三段")
    yield 'generator 2'

    console.log("执行结束")
    return 'generator 2'
}

console.log('main 0')
let gen = genDemo()
console.log(gen.next().value)
console.log('main 1')
console.log(gen.next().value)
console.log('main 2')
console.log(gen.next().value)
console.log('main 3')
console.log(gen.next().value)
console.log('main 4')
```

要搞懂函数为何能暂停和恢复，那你首先要了解协程的概念

> 协程是一种比线程更加轻量级的存在,你可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程,如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程。

进程包含多个线程，线程包含多个协程

> 正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。

上面代码可分析为

![img](https://static001.geekbang.org/resource/image/5e/37/5ef98bd693bcd5645e83418b0856e437.png)

父协程有自己的调用栈，gen 协程时也有自己的调用栈，当 gen 协程通过 yield 把控制权交给父协程时，V8 是如何切换到父协程的调用栈？当父协程通过 gen.next 恢复 gen 协程时，又是如何切换 gen 协程的调用栈？

- gen 协程和父协程是在主线程上交互执行的，并不是并发执行的，它们之前的切换是通过 yield 和 gen.next 来配合完成的
- 当在 gen 协程中调用了 yield 方法时，JavaScript 引擎会保存 gen 协程当前的调用栈信息，并恢复父协程的调用栈信息。同样，当在父协程中执行 gen.next 时，JavaScript 引擎会保存父协程的调用栈信息，并恢复 gen 协程的调用栈信息

为了直观理解父协程和 gen 协程是如何切换调用栈的，你可以参考下图：

![img](https://static001.geekbang.org/resource/image/92/40/925f4a9a1c85374352ee93c5e3c41440.png)

> 生成器就是协程的一种实现方式

所以我理解 协程是一个 模式，可以有任何实现的方式

### async与await

```js
async function foo() {
    console.log(1)
    let a = await 100
    console.log(a)
    console.log(2)
}
console.log(0)
foo()
console.log(3)
```

分析一下上面的执行流程，如下

![img](https://static001.geekbang.org/resource/image/8d/94/8dcd8cfa77d43d1fb928d8b001229b94.png)

重点在于 `await 100`这行

- 执行 打印0

- 执行foo函数，创建调用栈，

- 执行打印1

- 执行 await 然后创建一个 promise对象

  ```js
  
  let promise_ = new Promise((resolve,reject){
    resolve(100)
  })
  ```

  在这个 promise_ 对象创建的过程中，我们可以看到在 executor 函数中调用了 resolve 函数，JavaScript 引擎会将该任务提交给微任务队列

  然后 JavaScript 引擎会暂停当前协程的执行，将主线程的控制权转交给父协程执行，同时会将 promise_ 对象返回给父协程。

  主线程的控制权已经交给父协程了，这时候父协程要做的一件事是调用 promise_.then 来监控 promise 状态的改变。

- 打印3

- 检查微任务列表 执行 a 和 2

  ```js
  
  promise_.then((value)=>{
     //回调函数被激活后
    //将主线程控制权交给foo协程，并将vaule值传给协程
  })
  ```

  该回调函数被激活以后，会将主线程的控制权交给 foo 函数的协程，并同时将 value 值传给该协程。

  foo 协程激活之后，会把刚才的 value 值赋给了变量 a，然后 foo 协程继续执行后续语句，执行完成之后，将控制权归还给父协程。

  

