# 浏览器中的页面循环系统

 

## 消息队列和事件循环：页面是怎么“活”起来的？

### 使用单线程处理安排好的任务

- 缺点
  - 无法接受新的任务
- 解决方案
  - 利用事件循环来收集新的任务
  - 条件
    - 引入循环机制，for循环语句
    - 引入事件

具体如下

![img](https://static001.geekbang.org/resource/image/9e/e3/9e0f595324fbd5b7cd1c1ae1140f7de3.png)

### 处理其他线程发送过来的任务（多线程处理）

上面只适用单线程，如果是多线程 如下

![img](https://static001.geekbang.org/resource/image/2e/05/2eb6a8ecb7cb528da4663573d74eb305.png)

处理这种模式 就需要 用到**消息队列**

- 解决方案
  - 利用消息队列，是一种数据结构，可以存放要执行的任务，符合队列“先进先出”的特点，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。
- 改造步骤
  - 添加一个消息队列
  - IO 线程中产生的新任务添加进消息队列尾部
  - 渲染主线程会循环地从消息队列头部中读取任务，执行任务

如下

![img](https://static001.geekbang.org/resource/image/2a/ab/2ac6bc0361cb4690c5cc83d8abad22ab.png)

### 处理多进程发送过的任务

消息队列可以处理多线程通信，但是浏览器还需要多进程任务，其实和多线程一样，**渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息**

![img](https://static001.geekbang.org/resource/image/e2/c6/e2582e980632fd2df5043f81a11461c6.png)

### 消息队列中的任务类型

- 内部消息类型
  - 输入事件（鼠标滚动点击移动）
  - 微任务
  - 文件读写
  - websocket
  - JS的定时器
  - ...
- 页面相关的事件
  - JS执行
  - 解析DOM
  - 样式计算
  - 布局计算
  - css动画

以上这些事件都是在主线程中执行的，所以在编写 Web 应用时，你还需要衡量这些事件所占用的时长，并想办法解决单个任务占用主线程过久的问题。

### 安全退出线程

确定要退出当前页面时，页面主线程会设置一个退出标志的变量，在每次执行完一个任务时

### 页面使用单线程的缺点

页面线程所有执行的任务都来自于消息队列。消息队列是“先进先出”的属性，也就是说放入队列中的任务，需要等待前面的任务被执行完，才会被执行。

- 如何处理高优先级的任务
  - 消息队列中每个任务都是宏任务，在执行宏任务时，有例如DOM渲染这样的**微任务**执行那么就添加到当前宏任务的微任务队列，当宏任务的主任务列表执行完后，就会开始执行**微任务**列表
- 如何处理一个任务时长过长的问题
  - 所有任务是单线程执行，每次只能执行一个任务，任务时长过长就会导致后面的任务长时间等待，JavaScript 可以通过回调功能来规避这种问题，也就是让要执行的 JavaScript 任务滞后执行。

## WebAPI:setTimeout是如何实现的？

- 新建了一个 **延迟任务**消息队列，所有定时器都会在这个队列中
- 每当一个消息队列中的宏任务执行完成，就会执行 **延迟任务**消息队列中的任务（所以有时延时函数执行等待时长会比定时长）
- clearTimeout 实现就是传入 setTimeout 返回的 number，通过这个查找到相关的事件 id 然后在 延时队列中删掉即可

### 使用setTimeout 的注意事项

- 当前任务执行事件过久，会影响定时器任务的执行

  - 如下

  - ```js
    
    function bar() {
        console.log('bar')
    }
    function foo() {
        setTimeout(bar, 0);
        for (let i = 0; i < 5000; i++) {
            let i = 5+8+8+8
            console.log(i)
        }
    }
    foo()
    // 虽然延时 0 秒，但是需要先把 for 循环走完 才能走 延时函数，所以真实延时就是for循环走完后的时间
    ```

- 如果 setTimeout 存在嵌套调用，那么浏览器系统会设置最短时间间隔为 4 毫秒

- 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒

  - 如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1000 毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。

- 延时执行时间有最大值

  - Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，那么相当于延时值被设置为 0 了，这导致定时器会被立即执行。

- 使用 setTimeout 设置的回调函数中的 this 不符合直觉

  - 如果被 setTimeout 推迟执行的回调函数是某个对象的方法，那么该方法中的 this 关键字将指向全局环境，而不是定义时所在的那个对象，如果是严格模式，会被设置为 undefined。

## WebAPI:XMLHttpRequest是怎么实现的？

