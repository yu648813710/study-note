# 浏览器中JS的执行机制

## JS代码是按照顺序执行的吗？

> JS本身确实是按照顺序执行的，但是存在一些特殊场景比如变量提升和闭包

### 变量提升

> 所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined

变量提升如下所示

```js
showName() // 函数showName被执行
console.log(myname) // undefined
var myname = '极客时间'
function showName() { console.log('函数showName被执行');}
```

产生变量提升的原因是

- js引擎把函数和变量在执行之前提升到了代码开头

那这个是怎么处理的？看下面的执行流程

### 执行流程

因为变量提升所以引出一个问题，JS在浏览器执行中做了一些事情，分为编译阶段和执行阶段

#### 编译阶段

- 编译后生成两部分内容：`执行上下文` 和 `可执行代码`
  - `执行上下文`是js执行一段代码的云效环境
  - `执行上下文`存在一个变量环境的对象，该对象中保存了变量提升的内容
- 上个示例代码的分析
  - 第 1 行和第 2 行，由于这两行代码不是声明操作，所以 JavaScript 引擎不会做任何处理；
  - 第 3 行，由于这行是经过 var 声明的，因此 JavaScript 引擎将在环境对象中创建一个名为 myname 的属性，并使用 undefined 对其初始化；
  - 第 4 行，JavaScript 引擎发现了一个通过 function 定义的函数，所以它将函数定义存储到堆 (HEAP）中，并在环境对象中创建一个 showName 的属性，然后将该属性值指向堆中函数的位置

编译后有了可执行的上下文环境以及执行代码进入执行阶段

#### 执行阶段

- 上课示例代码的执行

  - 当执行到 showName 函数时，JavaScript 引擎便开始在变量环境对象中查找该函数，由于变量环境对象中存在该函数的引用，所以 JavaScript 引擎便开始执行该函数，并输出“函数 showName 被执行”结果。

  - 接下来打印“myname”信息，JavaScript 引擎继续在变量环境对象中查找该对象，由于变量环境存在 myname 变量，并且其值为 undefined，所以这时候就输出 undefined。

  - 接下来执行第 3 行，把“极客时间”赋给 myname 变量，赋值后变量环境中的 myname 属性值改变为“极客时间”，变量环境如下所示：

    ```js
    VariableEnvironment:
    	myname -> "极客时间",
            showName ->function : {console.log(myname)
    ```

- 代码出现相同的变量以及函数怎么处理？

  - 会在编译阶段，最后拿到的变量或者函数为最终值

## 调用栈：为什么JS会栈溢出

### 哪些代码为可以在编译的时候创建独立的上下文？

- 首先是全局上下文，JS执行全局代码的时候会创建全局上下文，并且整个页面生命周期内只有一份
- 当调用一个函数会创建执行上下文，一般情况执行结束上下文也会被摧毁
- 使用eval函数的时候（已经弃用）

### 函数调用和栈的关系

> JS函数调用会产生执行上下文，但是有时候可能一个函数里面还包有另外一个函数，所以执行上下文有可能是多个，而JS引擎就是用`栈`这种数据结构来管理`执行上下文的`

#### 什么是栈

- 一种数据结构容器
- 特点就是`先进后出`

### 什么是JS调用栈

- JS引擎管理`执行上下文`的栈结构
- JS引擎会把`执行上下文`压入栈中，把这种管理叫做调用栈

### 栈溢出

- JS引擎的调用栈是有大小的，超过一定的`执行上下文`就会报错
- 递归最容易因为没有边界条件导致栈溢出，所以有时候处理问题需要用setTimeout来优化，为什么使用定时器可以解决栈移除问题？ function foo() { setTimeout(foo, 0) } foo() 像setTimeout 、setInterval Promise 这样的全局函数不是js 的一部分，而是webapi 部分。 当遇到webApi 时，会将其回调函数(foo)交给web apis 处理，此时 调用栈 中foo 函数执行完毕，出栈，栈为空； 回调函数会被发送到任务队列中，等待event loop 事件循环将其捞出 重新放入到堆栈中 .... 参考：https://juejin.im/post/5d2d146bf265da1b9163c5c9#heading-15

## 块级作用域以及var缺陷以及const let出现

会出现变量提升得原因就是因为之前ES规范不支持块级作用域，因为当初设计这门语言的时候，并没有想到 JavaScript 会火起来，所以只是按照最简单的方式来设计。没有了块级作用域，再把作用域内部的变量统一提升无疑是最快速、最简单的设计，不过这也直接导致了函数中的变量无论是在哪里声明的，在编译阶段都会被提取到执行上下文的变量环境中，所以这些变量在整个函数体内部的任何地方都是能被访问的，这也就是 JavaScript 中的变量提升。

块级作用域是为了解决变量提升带来得缺陷

### 作用域

> 作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期

- 全局作用域
  - 在代码中得任何地方都可访问，其生命周期伴随着页面的生命周期
- 函数作用域
  - 函数内部得函数或者变量只能在函数内部访问，函数执行完后 内部得变量也会被销毁

### 变量提升缺陷

- 变量易被覆盖

  ```js
  
  
  /***********************没有块级作用域覆盖***************************/
  
  var myname = "极客时间"
  function showName(){
    console.log(myname); // undefined
    if(0){
     var myname = "极客邦"
    }
    console.log(myname); // undefined
  }
  showName()
  // 原因就是因为执行showName 得时候 if语句内得 myname被读取 导致出现变量提升覆盖了全局得 myname
  /**********************块级作用域未被覆盖****************************/
  
  let myname1 = "极客时间"
  function showName1(){
    console.log(myname1); // 极客时间
    if(0){
     let myname1 = "极客邦"
    }
    console.log(myname1); // 极客时间
  }
  showName1()
  
  /**************************************************/
  ```

  

- 变量在应该销毁得情况下未被销毁

  ```js
  /***********没有块级作用域得*************/
  function foo(){
    for (var i = 0; i < 7; i++) {
    }
    console.log(i); // 7未被销毁 因为 i 在foo函数作用域里存在
  }
  foo()
  
  ```

### 如何支持块级作用域

- 引入const与let

  为了解决块级作用域问题

- 如何支持块级作用域

  需要站在`执行上下文得角度`来看，代码如下

  ```js
  
  function foo(){
      var a = 1
      let b = 2
      {
        let b = 3
        var c = 4
        let d = 5
        console.log(a)
        console.log(b)
      }
      console.log(b) 
      console.log(c)
      console.log(d)
  }   
  foo()
  ```

  - 第一步编译并创建执行上下文
    - 函数内部var的变量，编译阶段全存放到`变量环境`中
    - 通过let的声明的变量，在编译阶段会被存放到`词法环境`
    - 函数的作用域块内部，通过let声明的变量并没有被存放在词法环境中
  - 第二部执行
    - 执行函数在找寻变量时 是按照 先 `词法环境`再`变量环境`，`词法环境`也是自上而下查找
    - `词法环境`内部维护了小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，会把内部的变量全部压入栈中，执行完作用域后然后从栈顶释放

### 暂时性死区

在执行块级作用域时，如果变量未被赋值直接访问，会报错 Cannot access '****' before initialization

- 原因
  - 在块作用域内，let声明的变量被提升，但变量只是创建被提升，初始化并没有被提升，在初始化之前使用变量，就会形成一个暂时性死区。

如下

```js
{
  console.log(myname25) 
  let myname25= '极客邦'
}
```



## 作用域链和闭包 ：代码中出现相同的变量，JavaScript引擎是如何选择的

### 作用域链

> 其实在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为 outer

- 寻找变量时JS引擎首先会在`当前的执行上下文`中查找变量，先找`词法环境`再`变量环境`
- 还没找到时就会找`outer`的外部引用变量环境，没找到继续找outer的outer一直找到全局的 `outer`，而全局的`outer`是指向`null`的，这个就是作用域链

### 词法作用域

> 词法作用域就是指作用域是由代码中函数**声明的位置来决定的**，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符，在编译的时候已经确定词法作用域了，和函数怎么调用没关系，词法作用域规定了 `outer`指向那里

如下

```js
function bar () {
	console.log(text)
}

function show () {
	{
		let text = 1
         bar()
	}
}

let text = 2
show() //  打印出来是2，原因就是 bar 定义在全局 所以它的词法作用域就在全局 ，编译的时候 outer自然指向全局，而全局下的 text是2 

```

### 闭包

之前的概念，闭包就是返回一个对象访问 函数内部的变量 。

接下来看demo

```jsx

function foo() {
    var myName = "极客时间"
    let test1 = 1
    const test2 = 2
    var innerBar = {
        getName:function(){
            console.log(test1)
            return myName
        },
        setName:function(newName){
            myName = newName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName("极客邦")
bar.getName()
console.log(bar.getName())
```

这个当然产生了闭包，而用刚才的知识就是 foo 函数虽然被 调用完成了，但是 bar 变量引用了 返回的 innerBar 导致 ，而innerBar的 outer 是 foo 函数的 环境上下文，所以 foo函数的 test1 以及 myName 变量就无法被销毁，所以只要调用 innerBar的 方法 就会访问这个未被销毁的 环境上下文，这个无法销毁的环境上下文 就是 foo 函数产生的闭包 

- 定义 
  - 在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。
  - 调用 顺序是 调用闭包 ，然后闭包里的 outer

### 闭包回收

闭包容易造成内存泄漏，因为无法被回收，通常，如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。避免这种现象的出现就是 把闭包 要被赋值的变量 定义为局部的 而不是全局，局部变量的函数调用完后 会直接 销毁函数，所以内部的 局部变量也会被销毁

