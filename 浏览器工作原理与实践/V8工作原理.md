# V8工作原理

## 栈空间和堆空间：数据是如何存储的？

> 主要是为了搞清楚JS的内存机制

### 让人疑惑的浅拷贝和深拷贝现象

```js

// 深拷贝

function foo(){
    var a = 1
    var b = a
    a = 2
    console.log(a) // 2
    console.log(b) // 1
}
foo()

...

// 浅拷贝

function foo(){
    var a = {name:"极客时间"}
    var b = a
    a.name = "极客邦" 
    console.log(a) // name  = "极客邦" 
    console.log(b) // name  = "极客邦" 
}
foo()

```

要解答这个现象需要弄清楚JS是什么类型语言，还需要搞清楚js的数据类型，以及数据类型的存储，而这个现象就是由数据类型存储引起的

### 语言类型分类

- 在使用之前就需要确认其变量数据类型的称为静态语言。相反地，我们把在运行过程中需要检查数据类型的语言称为动态语言。

- 支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言。

JS是 动态的弱类型，数据类型分为 原始类型 和引用类型

### 内存空间

js运行过程中的存储方式

- 代码空间，主要是存储执行代码，后面做介绍

- 栈空间，调用栈用来存储执行上下文的

  - 为什么引起浅拷贝，因为引用对象的 数据存在堆中，调用栈或者说执行上下文只存储乐对象的地址，所以浅拷贝只是复制了地址

  - 通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。

- 堆空间

  - 堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。

不能所有数据都放入`栈`中，因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。

比如一个函数执行完了 这个函数所占用的栈空间的环境上下文会立马被回收。

### 再谈闭包

因为正常函数执行完后 会被回收上下文，而闭包却还存在 可用变量, 所以闭包情况下会导致 基础类型的变量也在堆空间中

代码分析

```js

    
function foo() {
    var myName = "极客时间"
    let test1 = 1
    const test2 = 2
    var innerBar = { 
        setName:function(newName){
            myName = newName
        },
        getName:function(){
            console.log(test1)
            return myName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName("极客邦")
bar.getName()
console.log(bar.getName())

```

- 当 JavaScript 引擎执行到 foo 函数时，首先会编译，并创建一个空执行上下文。

- 在编译过程中，遇到内部函数 setName，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了 foo 函数中的 myName 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个“closure(foo)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 myName 变量。

- 接着继续扫描到 getName 方法时，发现该函数内部还引用变量 test1，于是 JavaScript 引擎又将 test1 添加到“closure(foo)”对象中。

- 这时候堆中的“closure(foo)”对象中就包含了 myName 和 test1 两个变量了。

- 由于 test2 并没有被内部函数引用，所以 test2 依然保存在调用栈中。

> 产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。

## 垃圾回收：垃圾数据是如何自动回收的？

> 通常情况下，垃圾数据回收分为手动回收和自动回收两种策略。C/C++都是手动回收，何时2分配内存，何时销毁内存由代码控制，当调用一个内存却没有释放这个内存，就会内存泄漏，另外一种使用的是自动垃圾回收的策略，如 JavaScript、Java、Python 等语言，产生的垃圾数据是由垃圾回收器来释放的

### 调用栈中的数据是如何回收的

分析代码来看

```js

function foo(){
    var a = 1
    var b = {name:"极客邦"}
    function showName(){
      var c = 2
      var d = {name:"极客时间"}
    }
    showName()
}
foo()
```

当执行foo时，调用栈和堆空间如下

![img](https://static001.geekbang.org/resource/image/d8/b0/d807ca19c2c8853ef5a38dca0fb79ab0.jpg)

> JS引擎执行JS时会有一个记录当前执行状态的`指针称为ESP`

- 当执行完showName函数，JS会把`ESP`下移到foo函数的执行上下文，这个下移操作就是销毁showName函数执行上下文的过程
- 下移后并不会销毁之前的栈空间，执行完后showName是无效空间，当有新的执行上下文会直接覆盖这块内存

#### 结论

当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。

### 堆数据回收

栈空间中环境上下文被回收了，但是引用对象存储在堆空间，还没有被回收，而堆空间的垃圾回收就需要JS中的垃圾回收器了，学习JS的垃圾回收期，先需要学习两个概念

#### 代际假说

- 特点

  - 大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；

  - 不死的对象活得更久

    这两个特点不仅仅适用于 JavaScript，同样适用于大多数的动态语言，如 Java、Python 等。

通常，垃圾回收算法有很多种，但是并没有哪一种能胜任所有的场景，你需要权衡各种场景，根据对象的生存周期的不同而使用不同的算法，以便达到最好的效果。

#### 分代收集

- V8会把堆分为两个区域，而且分别由把不同的垃圾回收器
  - 老生代
    - 主垃圾回收器负责
    - 存放生存时间久的对象
  - 新生代
    - 副垃圾回收器负责
    - 存放生存时间短的对象

#### 垃圾回收器流程

- 垃圾回收器的执行流程，不管什么类型的垃圾回收器流程是一致的
  - 标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。
  - 回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。
  - 做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。

- 副垃圾回收器

  - 垃圾回收比较频繁，因为空间不大，所以只要空间满了就要回收

  - 新生代中用 Scavenge 算法来处理

    ![img](https://static001.geekbang.org/resource/image/4f/af/4f9310c7da631fa5a57f871099bfbeaf.png)

      

  - 新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。

  - 在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。

  - 完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。

    由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以`为了执行效率，一般新生区的空间会被设置得比较小。`

  - 对象晋升策略

    - 新生区的空间不大，所以很容易被存活的对象装满整个区域,所以经过两次垃圾回收依然还存活的对象，会被移动到老生区中。

- 主垃圾回收器

  两个特点，一个是对象占用空间大，另一个是对象存活时间长。

  由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。

  - 标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。![img](https://static001.geekbang.org/resource/image/6c/69/6c8361d3e52c1c37a06699ed94652e69.png)
  - 接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：![img](https://static001.geekbang.org/resource/image/d0/85/d015db8ad0df7f0ccb1bdb8e31f96e85.png)这样会导致大量不连续的内存碎片，从而导致大对象无法分配到足够的连续内存，这个过程是`标记-清除`算法
  - 为了解决清除算法问题，产生了另外一个算法`标记-整理`，只有清除过程不同，是把标记存活的对象统一放到一个连续的内存区，然后清除其他不存活的连续内存区

#### 全停顿

> 由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。

- 所带来的问题
  - 新生代垃圾回收还好，比较小全停顿时间很短，但是旧生代内存比较大，会导致停顿时间很长，比如一个动画正在执行结果垃圾回收导致全停顿了，那么动画就暂停了
- 解决问题
  - V8用了`增量标记`算法解决这个问题，其实就是将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成
  - 这样垃圾回收分成了很多个小任务，就不会感受到页面卡顿了

## V8如何执行一段JS代码？

> 要深入理解 V8 的工作原理，你需要搞清楚一些概念和原理，比如接下来我们要详细讲解的`编译器（Compiler）`、`解释器（Interpreter）`、`抽象语法树（AST）`、`字节码（Bytecode）`、`即时编译器（JIT）`等概念，都是你需要重点关注的。

### 编译器和解释器

#### 意义

- 机器不能直接理解我们缩写的代码，所以执行代码之前需要编译或者解释然后`翻译`成机器能读懂的机器语言

#### 分类

- 编译器
  - 给编译型语言用的，如c/c++，GO等
  - 编译之后会直接`保留`机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次`重新编译`了
- 解释器
  - 给解释型语言用的，如python和js
  - 在每次运行时都需要通过解释器对程序进行动态解释和执行

#### 编译流程

![img](https://static001.geekbang.org/resource/image/4e/81/4e196603ecb78188e99e963e251b9781.png)

- 编译器
  - 在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。
- 解释器
  - 在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。

### V8怎么执行JS代码？

预览图

![img](https://static001.geekbang.org/resource/image/1a/ae/1af282bdc4036096c03074da53eb84ae.png)

V8 在执行过程中既有*解释器 Ignition*，又有*编译器 TurboFan*

字节码与汇编属于同一级别

- 生成抽象语法树AST和执行上下文
  - 先生成AST才生成执行上下文
  - 高级语言开发者可以理解，但是让编译器和解释器理解就非常困难，编译和解释器可以理解的就是AST，

#### AST生成阶段

- 第一阶段是分词（tokenize），又称为词法分析
- 第二阶段是解析（parse），又称为语法分析，

#### 生成字节码

> 字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。

之前是生成字节码 不生成机器码，后来因为内存占用问题，因为 V8 需要消耗大量的内存来存放转换后的机器码。为了解决内存占用问题，V8 团队大幅重构了引擎架构，引入字节码，并且抛弃了之前的编译器，最终花了将进四年的时间，实现了现在的这套架构。

#### 执行代码

![img](https://static001.geekbang.org/resource/image/66/8a/662413313149f66fe0880113cb6ab98a.png)

- 热点代码
  - 在 Ignition 执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。
- JIT 即时编译
  - 具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器便闪亮登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。

### JS性能优化

- 提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；
- 避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；
- 减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。
