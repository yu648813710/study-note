# V8工作原理

## 栈空间和堆空间：数据是如何存储的？

> 主要是为了搞清楚JS的内存机制

### 让人疑惑的浅拷贝和深拷贝现象

```js

// 深拷贝

function foo(){
    var a = 1
    var b = a
    a = 2
    console.log(a) // 2
    console.log(b) // 1
}
foo()

...

// 浅拷贝

function foo(){
    var a = {name:"极客时间"}
    var b = a
    a.name = "极客邦" 
    console.log(a) // name  = "极客邦" 
    console.log(b) // name  = "极客邦" 
}
foo()

```

要解答这个现象需要弄清楚JS是什么类型语言，还需要搞清楚js的数据类型，以及数据类型的存储，而这个现象就是由数据类型存储引起的

### 语言类型分类

- 在使用之前就需要确认其变量数据类型的称为静态语言。相反地，我们把在运行过程中需要检查数据类型的语言称为动态语言。

- 支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言。

JS是 动态的弱类型，数据类型分为 原始类型 和引用类型

### 内存空间

js运行过程中的存储方式

- 代码空间，主要是存储执行代码，后面做介绍

- 栈空间，调用栈用来存储执行上下文的

  - 为什么引起浅拷贝，因为引用对象的 数据存在堆中，调用栈或者说执行上下文只存储乐对象的地址，所以浅拷贝只是复制了地址

  - 通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。

- 堆空间

  - 堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。

不能所有数据都放入`栈`中，因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。

比如一个函数执行完了 这个函数所占用的栈空间的环境上下文会立马被回收。

### 再谈闭包

因为正常函数执行完后 会被回收上下文，而闭包却还存在 可用变量, 所以闭包情况下会导致 基础类型的变量也在堆空间中

代码分析

```js

    
function foo() {
    var myName = "极客时间"
    let test1 = 1
    const test2 = 2
    var innerBar = { 
        setName:function(newName){
            myName = newName
        },
        getName:function(){
            console.log(test1)
            return myName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName("极客邦")
bar.getName()
console.log(bar.getName())

```

- 当 JavaScript 引擎执行到 foo 函数时，首先会编译，并创建一个空执行上下文。

- 在编译过程中，遇到内部函数 setName，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了 foo 函数中的 myName 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个“closure(foo)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 myName 变量。

- 接着继续扫描到 getName 方法时，发现该函数内部还引用变量 test1，于是 JavaScript 引擎又将 test1 添加到“closure(foo)”对象中。

- 这时候堆中的“closure(foo)”对象中就包含了 myName 和 test1 两个变量了。

- 由于 test2 并没有被内部函数引用，所以 test2 依然保存在调用栈中。

> 产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。

## 垃圾回收：垃圾数据是如何自动回收的？
