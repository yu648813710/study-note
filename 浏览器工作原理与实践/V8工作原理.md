# V8工作原理

## 栈空间和堆空间：数据是如何存储的？

> 主要是为了搞清楚JS的内存机制

### 让人疑惑的浅拷贝和深拷贝现象

```js

// 深拷贝

function foo(){
    var a = 1
    var b = a
    a = 2
    console.log(a) // 2
    console.log(b) // 1
}
foo()

...

// 浅拷贝

function foo(){
    var a = {name:"极客时间"}
    var b = a
    a.name = "极客邦" 
    console.log(a) // name  = "极客邦" 
    console.log(b) // name  = "极客邦" 
}
foo()

```

要解答这个现象需要弄清楚JS是什么类型语言，还需要搞清楚js的数据类型，以及数据类型的存储，而这个现象就是由数据类型存储引起的

### 语言类型分类

- 在使用之前就需要确认其变量数据类型的称为静态语言。相反地，我们把在运行过程中需要检查数据类型的语言称为动态语言。

- 支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言。

JS是 动态的弱类型，数据类型分为 原始类型 和引用类型

### 内存空间

js运行过程中的存储方式

- 代码空间，主要是存储执行代码，后面做介绍

- 栈空间，调用栈用来存储执行上下文的

  - 为什么引起浅拷贝，因为引用对象的 数据存在堆中，调用栈或者说执行上下文只存储乐对象的地址，所以浅拷贝只是复制了地址

  - 通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。

- 堆空间

  - 堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。

不能所有数据都放入`栈`中，因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。

比如一个函数执行完了 这个函数所占用的栈空间的环境上下文会立马被回收。

### 再谈闭包

因为正常函数执行完后 会被回收上下文，而闭包却还存在 可用变量, 所以闭包情况下会导致 基础类型的变量也在堆空间中

代码分析

```js

    
function foo() {
    var myName = "极客时间"
    let test1 = 1
    const test2 = 2
    var innerBar = { 
        setName:function(newName){
            myName = newName
        },
        getName:function(){
            console.log(test1)
            return myName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName("极客邦")
bar.getName()
console.log(bar.getName())

```

- 当 JavaScript 引擎执行到 foo 函数时，首先会编译，并创建一个空执行上下文。

- 在编译过程中，遇到内部函数 setName，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了 foo 函数中的 myName 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个“closure(foo)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 myName 变量。

- 接着继续扫描到 getName 方法时，发现该函数内部还引用变量 test1，于是 JavaScript 引擎又将 test1 添加到“closure(foo)”对象中。

- 这时候堆中的“closure(foo)”对象中就包含了 myName 和 test1 两个变量了。

- 由于 test2 并没有被内部函数引用，所以 test2 依然保存在调用栈中。

> 产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。

## 垃圾回收：垃圾数据是如何自动回收的？

> 通常情况下，垃圾数据回收分为手动回收和自动回收两种策略。C/C++都是手动回收，何时2分配内存，何时销毁内存由代码控制，当调用一个内存却没有释放这个内存，就会内存泄漏，另外一种使用的是自动垃圾回收的策略，如 JavaScript、Java、Python 等语言，产生的垃圾数据是由垃圾回收器来释放的

### 调用栈中的数据是如何回收的

分析代码来看

```js

function foo(){
    var a = 1
    var b = {name:"极客邦"}
    function showName(){
      var c = 2
      var d = {name:"极客时间"}
    }
    showName()
}
foo()
```

当执行foo时，调用栈和堆空间如下

![img](https://static001.geekbang.org/resource/image/d8/b0/d807ca19c2c8853ef5a38dca0fb79ab0.jpg)

> JS引擎执行JS时会有一个记录当前执行状态的`指针称为ESP`

- 当执行完showName函数，JS会把`ESP`下移到foo函数的执行上下文，这个下移操作就是销毁showName函数执行上下文的过程
- 下移后并不会销毁之前的栈空间，执行完后showName是无效空间，当有新的执行上下文会直接覆盖这块内存

#### 结论

当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。

### 堆数据回收

栈空间中环境上下文被回收了，但是引用对象存储在堆空间，还没有被回收，而堆空间的垃圾回收就需要JS中的垃圾回收器了，学习JS的垃圾回收期，先需要学习两个概念

#### 代际假说

- 特点

  - 大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；

  - 不死的对象活得更久

    这两个特点不仅仅适用于 JavaScript，同样适用于大多数的动态语言，如 Java、Python 等。

通常，垃圾回收算法有很多种，但是并没有哪一种能胜任所有的场景，你需要权衡各种场景，根据对象的生存周期的不同而使用不同的算法，以便达到最好的效果。

#### 分代收集

- V8会把堆分为两个区域，而且分别由把不同的垃圾回收器
  - 老生代
    - 主垃圾回收器负责
    - 存放生存时间久的对象
  - 新生代
    - 副垃圾回收器负责
    - 存放生存时间短的对象

#### 垃圾回收器流程

- 垃圾回收器的执行流程，不管什么类型的垃圾回收器流程是一致的
  - 标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。
  - 回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。
  - 做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。

- 副垃圾回收器

  - 垃圾回收比较频繁，因为空间不大，所以只要空间满了就要回收

  - 新生代中用 Scavenge 算法来处理

    ![img](https://static001.geekbang.org/resource/image/4f/af/4f9310c7da631fa5a57f871099bfbeaf.png)

    ​  

  - 新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。

  - 在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。

  - 完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。

    由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以`为了执行效率，一般新生区的空间会被设置得比较小。`

  - 对象晋升策略

    - 新生区的空间不大，所以很容易被存活的对象装满整个区域,所以经过两次垃圾回收依然还存活的对象，会被移动到老生区中。

- 主垃圾回收器

  两个特点，一个是对象占用空间大，另一个是对象存活时间长。

  由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。

  - 标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。![img](https://static001.geekbang.org/resource/image/6c/69/6c8361d3e52c1c37a06699ed94652e69.png)
  - 接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：![img](https://static001.geekbang.org/resource/image/d0/85/d015db8ad0df7f0ccb1bdb8e31f96e85.png)这样会导致大量不连续的内存碎片，从而导致大对象无法分配到足够的连续内存，这个过程是`标记-清除`算法
  - 为了解决清除算法问题，产生了另外一个算法`标记-整理`，只有清除过程不同，是把标记存活的对象统一放到一个连续的内存区，然后清除其他不存活的连续内存区

#### 全停顿

> 由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。

- 所带来的问题
  - 新生代垃圾回收还好，比较小全停顿时间很短，但是旧生代内存比较大，会导致停顿时间很长，比如一个动画正在执行结果垃圾回收导致全停顿了，那么动画就暂停了
- 解决问题
  - V8用了`增量标记`算法解决这个问题，其实就是将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成
  - 这样垃圾回收分成了很多个小任务，就不会感受到页面卡顿了

​

​

​
